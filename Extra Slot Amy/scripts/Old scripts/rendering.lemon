function bool Standalone.drawCharacterSprite(u8 character, u8 variant, s16 px, s16 py, bool asSmallGhost)
{
	if (char.character == CHARACTER_TAILS && XtraChar == 3)
	{
		return BluestreakAmyRoseRenderingScript(character, variant, px, py, asSmallGhost)
	}
	else
	{
		return base.Standalone.drawCharacterSprite(character, variant, px, py, asSmallGhost)
	}
}

global u8 HammerAnimFrame
global u8 RollRotationValue

function bool Standalone.onWriteToSpriteTable(s16 px, s16 py, u16 renderQueue)
{
	u8 gameMode = global.game_mode & 0x7f
	bool prioFlag = (objA0.sprite_attributes & 0x8000) != 0
	u64 key
	u64 paletteKey
	u8 atex
	u8 flags = ((objA0.render_flags & 0x01) ? SPRITE_FLAG_FLIP_X : 0) | ((objA0.render_flags & 0x02) ? SPRITE_FLAG_FLIP_Y : 0) | ((objA0.sprite_attributes & 0x8000) ? SPRITE_FLAG_PRIO : 0)

	if (objA0.update_address == 0x00d30c || objA0.update_address == 0x00d42c)
	{
		if (objA0.animation.sprite == 5 && objA0.animation.timer == 3)
		{
			key = "dataSel_slot3"
			if (Renderer.hasCustomSprite(key))
				Renderer.drawCustomSprite(key, px-0x0f, py-0x25, 0, SPRITE_FLAG_PRIO, 0xffff)
		}
	}

	if (objA0.update_address == 0x00d42c)
	{
		if (objA0.animation.sprite == 5 && objA0.animation.timer == 3)
		{
			// Draw icons for lives & continues
			key = "dataSel_lifeContinue_slot3"
			if (Renderer.hasCustomSprite(key))
			{
				if (u8[A0 + 0x05] != 0x00 && u8[A0 + 0x08] != 0x01)
				{
					Renderer.drawCustomSprite(key, px-16, py + 8, 0, SPRITE_FLAG_PRIO, 0xffff)
				}
			}
		}
	}

	if (XtraChar == 3)
	{
		//Bluespheres Palette
		if (gameMode == 0x34 || gameMode == 0x48 || gameMode == 0x2c || gameMode == 0x30 || global.game_mode == 0x85 || global.game_mode == 0x87) //just check for mighty, thanks! // 0x85 || 0x87 checks the custom menu of BS Time atttack
		{
			// Characters in special stage
			if (objA0.update_address == 0x00903e)// || objA0.update_address == 0x00927a) Just player one, thanks!
			{
				paletteKey = "bluesphere_palette_slot3"
				u8 character = getMainCharacter()
				key = stringformat("bluesphere_slot3_0x%02x", objA0.animation.sprite)
				if (Renderer.hasCustomSprite(key))
				{
					// Check if there's also a custom palette
					if (System.hasExternalPaletteData(paletteKey, 0))
					{
						atex = 0x40 + character * 0x20
					}
				}
				else //let's say someone deleted the bluespheres sprites...at least they'll see sonic...
				{
					//I don't care it's internal sprite rendering! Pick the external palette ANYWAY!

					if (System.hasExternalPaletteData(paletteKey, 0))
					{
						atex = 0x40 + character * 0x20
					}
					key = Renderer.setupCustomCharacterSprite(0x0aaa7c, 0x0abe14, objA0.mapping_offset, objA0.animation.sprite, 0x00)
				}
				Renderer.drawCustomSprite(key, px, py, atex, flags, renderQueue)
				return true
			}
			// Tails' tails object in special stage isn't here
		}
		// BlueSpheres extra mode
		if ((gameMode == 0x30 || gameMode == 0x2c) && blueSphereEXS)
		{
			if (char.animation.sprite >= 0xb0 && char.animation.sprite <= 0xb4 && objA0.update_address != 0x04e202 && objA0.update_address != 0x04e2f0)
			{
				atex = 0x40 + getMainCharacter() * 0x20
				paletteKey = getCharacterPaletteKey(char.character)
				if (System.hasExternalPaletteData(paletteKey, 0))
				{
					u16 numColors = System.loadExternalPaletteData(paletteKey, 0, 0x800000, 0x20)
					if (numColors > 0)
					{
						u32 dest = 0x802180 + getMainCharacter() * 0x40
						for (u16 i = 0; i < numColors; ++i)
						{
							u16[dest + i * 2] = packColor(u32[0x800000 + i * 4])
						}
					}
				}
				key = stringformat("character_slot3_0x%02x", objA0.animation.sprite)
				Renderer.drawCustomSprite(key, px, py, atex, flags, renderQueue)
				return true
			}
		}
	}
	return base.Standalone.onWriteToSpriteTable(px, py, renderQueue)
}

function bool BluestreakAmyRoseRenderingScript(u8 character, u8 variant, s16 px, s16 py, bool asSmallGhost)
{
	if ((char.animation.sprite >= 0x96 && char.animation.sprite <= 0x98) && (AmyJumpball == 1) && XtraChar == 3)
	{
		if (char.flags & char.flag.FACING_LEFT)
		{
			if (abs(char.groundspeed) <= 0x300)
			{
				RollRotationValue -= 0xa
			}
			if (abs(char.groundspeed) >= 0x300) && (abs(char.groundspeed) <= 0x600)
			{
				RollRotationValue -= 0x11
			}
			if (abs(char.groundspeed) >= 0x600)
			{
				RollRotationValue -= 0x17
			}
		}
		else
		{
			if (abs(char.groundspeed) <= 0x300)
			{
				RollRotationValue += 0xa
			}
			if (abs(char.groundspeed) >= 0x300) && (abs(char.groundspeed) <= 0x600)
			{
				RollRotationValue += 0x11
			}
			if (abs(char.groundspeed) >= 0x600)
			{
				RollRotationValue += 0x17
			}
		}
	}

	u64 jumpballanimcycle = ""
	jumpballanimcycle = stringformat("jumpball_effect_slot3_%d", (level.framecounter >> 2) % 8)

	bool isPlayer1 = (variant == 0)
	u32 characterAddress = isPlayer1 ? 0xffffb000 : 0xffffb04a

	// Check only needed for Tails' tails
	if (variant == 2)
	{
		// No smooth rotation in Slot Machine
		if (global.zone == 0x15)
			return false

		characterAddress = 0xffff0000 + u16[A0 + 0x30]

		// Do not render when blinking after hit
		if (u8[characterAddress + 0x34] != 0 && (u8[characterAddress + 0x34] & 0x04) == 0)
		{
			// Prevent emulator-like rendering
			return true
		}

		// Do not render when Tails looks into the background (e.g. LBZ 2 end cutscene) and in DEZ gravity transporters
		if (u8[characterAddress + 0x22] >= 0x55 && u8[characterAddress + 0x22] <= 0x5b)
		{
			// Prevent emulator-like rendering
			return true
		}

		isPlayer1 = (characterAddress == 0xffffb000)
		character = CHARACTER_TAILS
	}

	if (level.vertical_wrap == 0xff00)
	{
		// For vertically wrapping levels, "normalize" py into interval [-move_area.bottom.target * 3/4, -move_area.bottom.target * 1/4]
		py &= level.height.bitmask
		if (py > move_area.bottom.target * 3/4 && move_area.bottom.target >= 0xe0)	// move_area.bottom.target is very low in DEZ boss act
			py -= move_area.bottom.target
	}

	u8 animationSprite = char.animation.sprite
	u16 animationSpriteEx = Standalone.getModdedAnimationSpriteEx(character, animationSprite)
	u8 flags = (char.render_flags & 0x03)
	u8 angle = 0
	u64 key = 0
	u8 rotationMode = 0

	if (variant < 2)
	{
		if (character == CHARACTER_TAILS && animationSpriteEx == animationSprite)	// Last check is only false if modded scripts made their own changes
		{
			if (!super.active.tails && (( abs(char.groundspeed) >= 0xa00) && (char.animation.sprite >= 0x21 && char.animation.sprite <= 0x30) ))
			{
				if (!Game.getSetting(SETTING_SMOOTH_ROTATION))
				{
					angle = (animationSprite - 0x21) / 4 * 0xe0
					if (char.flags & char.flag.FACING_LEFT)
						angle = -angle
					animationSprite = 0x21 + (animationSprite - 0x21) % 4
				}
				//ONLY RUN
				animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + (level.framecounter & 0x03)
				key = stringformat("amy_fastrun_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
			}
			// Special handling for Drop Dash & Super Peel-Out
			if (char.state == char.state.STANDING) && (super.active.tails != 0)
			{
				animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + ((level.framecounter >> 3) & 0x01)
			}
			if (animationSprite >= 0x96 && animationSprite <= 0x98) && (abs(char.groundspeed) <= 0x300)
			{
				animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + ((level.framecounter >> 2) & 0x07)
			}
			if (animationSprite >= 0x96 && animationSprite <= 0x98) && (abs(char.groundspeed) >= 0x300) && (abs(char.groundspeed) <= 0x600)
			{
				animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + ((level.framecounter >> 1) & 0x07)
			}
			if (animationSprite >= 0x96 && animationSprite <= 0x98) && (abs(char.groundspeed) >= 0x600)
			{
				animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + (level.framecounter & 0x07)
			}
			if (animationSprite >= 0x86 && animationSprite <= 0x88)
			{
				animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + (level.framecounter & 0x07)
			}
			if (HammerSwingTimer != 0)
			{
				animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + ((HammerAnimFrame) & 0x07)
			}
			if (HammerJumpTimer != 0)
			{
				animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + ((HammerAnimFrame) & 0x07)
			}
		}

		if (Game.getSetting(SETTING_SMOOTH_ROTATION))
		{
			// Character
			if (animationSprite >= 0x01 && animationSprite <= 0x20)
			{
				animationSprite = 0x01 + (animationSprite - 0x01) % 8
				rotationMode = 1
			}
			else if (animationSprite >= 0x21 && animationSprite <= 0x30)
			{
				animationSprite = 0x21 + (animationSprite - 0x21) % 4
				rotationMode = 1
			}
			else if (animationSprite >= 0x78 && animationSprite <= 0x7f)
			{
				animationSprite = 0x78
				rotationMode = 2
			}
			else if (character == CHARACTER_TAILS && animationSprite >= 0xc3 && animationSprite <= 0xca)
			{
				animationSprite = 0xc3 + (animationSprite - 0xc3) % 2
				rotationMode = 1
			}
			else if (character == CHARACTER_KNUCKLES && animationSprite == 0xc0)
			{
				// Only for DDZ
				rotationMode = 1
			}

			if (rotationMode != 0)
			{
				s8 oldRotation = isPlayer1 ? oldRotationPlayer1 : oldRotationPlayer2
				flags = char.flags & char.flag.FACING_LEFT		// This really has to be "char.flags", not "char.render_flags"

				angle = char.rotation
				if (rotationMode == 1)
				{
					if (abs(s8(char.rotation)) <= 0x10 && abs(s8(oldRotation)) <= 0x10)
					{
						angle = 0
					}

					if (angle != char.rotation)
					{
						s8 diff = angle - oldRotation
						angle = oldRotation + clamp(diff, -3, 3)
					}
				}
			}

			if (isPlayer1)
				oldRotationPlayer1 = angle
			else
				oldRotationPlayer2 = angle
		}

		if (!Game.getSetting(SETTING_SMOOTH_ROTATION))
		{
			// Character
			if (animationSprite >= 0x01 && animationSprite <= 0x20) && (char.state == char.state.RUNNING)
			{

				angle = (animationSprite - 0x01) / 8 * 224
				if (char.flags & char.flag.FACING_LEFT)
					angle = -angle
				animationSprite = 0x01 + (animationSprite - 0x01) % 8
			}

			else if (animationSprite >= 0x21 && animationSprite <= 0x30) && (char.state == char.state.RUNNING)
			{
				angle = (animationSprite - 0x21) / 4 * 0xe0
				if (char.flags & char.flag.FACING_LEFT)
					angle = -angle
				animationSprite = 0x21 + (animationSprite - 0x21) % 4
			}
			else if (character == CHARACTER_TAILS && animationSprite >= 0xc3 && animationSprite <= 0xca)
			{
				angle = (animationSprite - 0xc3) / 2 * 224
				if (char.flags & char.flag.FACING_LEFT)
					angle = -angle
				animationSprite = 0xc3 + (animationSprite - 0xc3) % 2
			}
			else if (animationSprite >= 0x78 && animationSprite <= 0x7f)
			{
				animationSprite = 0x78
				rotationMode = 1
			}
		}

		if (animationSpriteEx >= 0x100)
		{
			// Special handling for Drop Dash & Super Peel-Out
			if (animationSpriteEx >= CHAR_ANIMSPRITE_SONIC_PEELOUT)
			{
				if (char.state == char.state.STANDING) && (super.active.tails != 0)
				{
					key = stringformat("character_superslot3_stand_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
				}
				if (animationSprite >= 0x96 && animationSprite <= 0x98)
				{
					if (super.active.tails != 0)
					{
						key = stringformat("character_superslot3_roll_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
					}
					else
					{
						key = stringformat("character_slot3_roll_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
					}
				}
				if (animationSprite >= 0x86 && animationSprite <= 0x88)
				{
					key = stringformat("character_slot3_spindash_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
				}
				if (HammerSwingTimer != 0)
				{
					if (super.active.tails != 0)
					{
						key = stringformat("character_superslot3_hammer_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
					}
					else
					{
						key = stringformat("character_slot3_hammer_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
					}
				}
				if (HammerJumpTimer != 0)
				{
					if (super.active.tails != 0)
					{
						key = stringformat("character_superslot3_hammer_jump_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
					}
					else
					{
						key = stringformat("character_slot3_hammer_jump_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
					}
				}
			}
			else
			{
				key = stringformat("sonic_dropdash_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_DROPDASH)
			}
		}
		timeattack.animSpriteEx = animationSpriteEx

		if (key == 0)
		{
			if (character == CHARACTER_SONIC)
			{
				key = stringformat(super.active ? "character_supersonic_0x%02x" : "character_sonic_0x%02x", animationSprite)
			}
			else if (character == CHARACTER_TAILS && XtraChar == 3)
			{
				key = stringformat(super.active.tails ? "character_superslot3_0x%02x" : "character_slot3_0x%02x", animationSprite)
			}
			else if (character == CHARACTER_KNUCKLES)
			{
				key = stringformat("character_knuckles_0x%02x", animationSprite)
			}

			if (!Renderer.hasCustomSprite(key))
			{
				u32 sourceBase    = (character == CHARACTER_SONIC) ? ((animationSprite >= 0xda) ? 0x140060 : 0x100000) : (character == CHARACTER_TAILS) ? ((animationSprite >= 0xd1) ? 0x143d00 : 0x3200e0) : 0x1200e0
				u32 tableAddress  = (character == CHARACTER_SONIC) ? (super.active ? 0x148378 : 0x148182) : (character == CHARACTER_TAILS) ? 0x14a08a : 0x14bd0a
				u32 mappingOffset = (character == CHARACTER_SONIC) ? (super.active ? 0x146816 : 0x146620) : (character == CHARACTER_TAILS) ? 0x148eb8 : 0x14a8d6		// Not really necessary here, we could also use "char.mapping_offset"

				key = Renderer.setupCustomCharacterSprite(sourceBase, tableAddress, mappingOffset, animationSprite, 0x00)
			}
		}
	}
	else
	{
		if (Game.getSetting(SETTING_SMOOTH_ROTATION))
		{
			// Tails' tails
			if (animationSprite >= 0x05 && animationSprite <= 0x14)
			{
				animationSprite = 0x05 + (animationSprite - 0x05) % 4
				angle = lookupAngleByVector(s16[characterAddress + 0x18], s16[characterAddress + 0x1a])

				flags = 0
				if (objA0.flags2a & 0x01)
				{
					flags |= SPRITE_FLAG_FLIP_X
					angle += 0x80
				}
				if (global.inv_gravity)
				{
					flags ^= SPRITE_FLAG_FLIP_Y
					angle = -angle
				}
			}
		}

		key = stringformat("character_tails_tails_0x%02x", animationSprite)
		if (!Renderer.hasCustomSprite(key))
		{
			key = Renderer.setupCustomCharacterSprite(0x336620, 0x344d74, 0x344bb8, animationSprite, 0x00)
		}
	}

	u16 renderQueue = 0xa000 - char.sprite_priority
	u8 atex = (char.sprite_attributes >> 9) & 0x30
	if (EXTENDED_CHARACTER_PALETTES)
		atex = 0x40 + character * 0x20

	if (char.sprite_attributes & 0x8000)
		flags |= SPRITE_FLAG_PRIO

	if (rotationMode != 0 && global.inv_gravity)
	{
		// Correction for inverse gravity
		angle = 128 - angle
		flags ^= SPRITE_FLAG_FLIP_X
	}


	if (Renderer.hasCustomSprite("MiniCharsCompatibility")) // MiniChars Lock-On
	{
		u8 spritescale = 0x9400
		u8 spritetailsoffsety = 3
		u8 spriterolloffsety = 3
		u8 spritepullyoffsety = 7
		// Render character
		if (asSmallGhost)
		{
			Renderer.drawCustomSprite(key, px, py, atex, flags | SPRITE_FLAG_PRIO, 0xa800, angle, 0xc0ffffff, 0x8000)
		}
		else
		{
				if (variant < 2)
				{
					if (char.character == CHARACTER_TAILS) 
					{
						Renderer.drawCustomSprite(key, px, py + spritetailsoffsety, atex, flags, renderQueue, angle, 0xffffffff, spritescale)
					}
					else if (char.state == char.state.ROLLING) || (char.character == CHARACTER_SONIC) && (char.state == char.state.SONIC_DROPDASH)
					{
						Renderer.drawCustomSprite(key, px, py + spriterolloffsety, atex, flags, renderQueue, angle, 0xffffffff, spritescale)
					}
					else if ((animationSprite >= 0x90 && animationSprite <= 0x95) || (animationSprite >= 0xe4 && animationSprite <= 0xea) || (animationSprite >= 0x80 && animationSprite <= 0x85)) && (char.state < 0x30)
					{
						Renderer.drawCustomSprite(key, px, py - spritepullyoffsety, atex, flags, renderQueue, angle, 0xffffffff, spritescale)
					}
					else
					{
						Renderer.drawCustomSprite(key, px, py, atex, flags, renderQueue, angle, 0xffffffff, spritescale)
					}
				}
				else
				{
					Renderer.drawCustomSprite(key, px, py + spritetailsoffsety, atex, flags, renderQueue, angle, 0xffffffff, spritescale)
				}
		}

		bool useAfterImages
		if (isPlayer1)
		{
			if ((super.active == 0xff) || (super.active.tails == 0xff))
			{
				useAfterImages = true
			}
			else
			{
				if (Game.getSetting(SETTING_SPEEDUP_AFTERIMGS))
				{
					useAfterImages = ((u8[characterAddress + 0x2b] & char.bonus.SPEED_UP) != 0)
				}
			}
		}

		if (useAfterImages)
		{
			// Additional offset for Sonic charging a Super Peel-Out (either Hyper Sonic or with Speed Shoes)
			s16 afterImagesOffsetX = 0
			if (char.character == CHARACTER_SONIC && char.spindash == 0x80)
			{
				afterImagesOffsetX = (char.groundspeed >> 7) * ((char.flags & char.flag.FACING_LEFT) ? 1 : -1)
			}

			for (s8 i = 3; i > 0; --i)
			{
				A1 = 0xffffe500 + u8(posbackup.offset.player1 - (i * 8 + 4))
				s16 px0 = u16[A1] - camera.foreground.x.u16 + (i * afterImagesOffsetX / 4)
				s16 py0 = u16[A1+2] - camera.foreground.y.u16
			}
		}

	}
	else
	{
		// Render character
		if (asSmallGhost)
		{
			Renderer.drawCustomSprite(key, px, py, atex, flags | SPRITE_FLAG_PRIO, 0xa800, angle, 0xc0ffffff, 0x8000)
		}
		else
		{
			if (AmyJumpball == 1)
			{
				if (char.animation.sprite >= 0x96 && char.animation.sprite <= 0x98)
				{
					Renderer.drawJumpballShine(px, py)

					if (level.framecounter & 0x01)
					{
						if (global.inv_gravity)
						{
							Renderer.drawCustomSprite(jumpballanimcycle, px, py, atex, flags, renderQueue, 128, 255)
						}
						else
						{
							Renderer.drawCustomSprite(jumpballanimcycle, px, py, atex, flags, renderQueue, 0, 255)
						}
					}
					else
					{
						if (global.inv_gravity)
						{
							if (super.active.tails)
							{
								Renderer.drawCustomSprite("character_superslot3_roll_1", px, py, atex, flags, renderQueue, -RollRotationValue, 255)
							}
							else
							{
								Renderer.drawCustomSprite("character_slot3_roll_1", px, py, atex, flags, renderQueue, -RollRotationValue, 255)
							}
						}
						else
						{
							if (super.active.tails)
							{
								Renderer.drawCustomSprite("character_superslot3_roll_1", px, py, atex, flags, renderQueue, RollRotationValue, 255)
							}
							else
							{
								Renderer.drawCustomSprite("character_slot3_roll_1", px, py, atex, flags, renderQueue, RollRotationValue, 255)
							}
						}
					}
				}

				else
				{
					Renderer.drawCustomSprite(key, px, py, atex, flags, renderQueue, angle, 255)
				}
			}
			else
			{
				Renderer.drawCustomSprite(key, px, py, atex, flags, renderQueue, angle, 255)
			}
		}

		bool useAfterImages
		if (isPlayer1)
		{
			if ((super.active == 0xff) || (super.active.tails == 0xff))
			{
				useAfterImages = true
			}
			else
			{
				if (Game.getSetting(SETTING_SPEEDUP_AFTERIMGS))
				{
					useAfterImages = ((u8[characterAddress + 0x2b] & char.bonus.SPEED_UP) != 0)
				}
			}
		}

		if (useAfterImages)
		{
			// Additional offset for Sonic charging a Super Peel-Out (either Hyper Sonic or with Speed Shoes)
			s16 afterImagesOffsetX = 0
			if (char.character == CHARACTER_SONIC && char.spindash == 0x80)
			{
				afterImagesOffsetX = (char.groundspeed >> 7) * ((char.flags & char.flag.FACING_LEFT) ? 1 : -1)
			}

			for (s8 i = 3; i > 0; --i)
			{
				A1 = 0xffffe500 + u8(posbackup.offset.player1 - (i * 8 + 4))
				s16 px0 = u16[A1] - camera.foreground.x.u16 + (i * afterImagesOffsetX / 4)
				s16 py0 = u16[A1+2] - camera.foreground.y.u16
				
				if (AmyJumpball == 1)
				{
					if (char.animation.sprite >= 0x96 && char.animation.sprite <= 0x98)
					{
						
						if (level.framecounter & 0x01)
						{
							if (global.inv_gravity)
							{
								Renderer.drawCustomSprite(jumpballanimcycle,  px0, py0, atex, flags, renderQueue - i, 128, 192 - i * 32)
							}
							else
							{
								Renderer.drawCustomSprite(jumpballanimcycle,  px0, py0, atex, flags, renderQueue - i, 0, 192 - i * 32)
							}
						}
						else
						{
							if (global.inv_gravity)
							{
								if (super.active.tails)
								{
									Renderer.drawCustomSprite("character_superslot3_roll_1",  px0, py0, atex, flags, renderQueue - i, -RollRotationValue, 192 - i * 32)
								}
								else
								{
									Renderer.drawCustomSprite("character_slot3_roll_1",  px0, py0, atex, flags, renderQueue - i, -RollRotationValue, 192 - i * 32)
								}
							}
							else
							{
								if (super.active.tails)
								{
									Renderer.drawCustomSprite("character_superslot3_roll_1",  px0, py0, atex, flags, renderQueue - i, RollRotationValue, 192 - i * 32)
								}
								else
								{
									Renderer.drawCustomSprite("character_slot3_roll_1",  px0, py0, atex, flags, renderQueue - i, RollRotationValue, 192 - i * 32)
								}
							}
						}
					}

					else
					{
						Renderer.drawCustomSprite(key, px0, py0, atex, flags, renderQueue - i, angle, 192 - i * 32)
					}
				}
				else
				{
					Renderer.drawCustomSprite(key, px0, py0, atex, flags, renderQueue - i, angle, 192 - i * 32)
				}
			}
		}
	}

	// Prevent emulator-like rendering
	return true
}

function void Renderer.drawJumpballShine(u16 px, u16 py)
{
	u64 jumpballshineanimcycle = ""  
	jumpballshineanimcycle = stringformat("jumpball_effect_shine_%d", (level.framecounter >> 2) % 8)
	Renderer.drawCustomSprite(jumpballshineanimcycle, px, py, 0, 0x00, 0xe000, RollRotationValue / 2, 0xffffffff, 0xaaaa)
}

function bool Standalone.onDrawVdpSpriteCompound(s16 px, s16 py, u8 size, u16 index, u16 renderQueue, u8 spriteCounter)
{
	if (objA0.update_address == 0x00d30c || objA0.update_address == 0x00d42c)
    {
        if (index == 0xab0b || index == 0xab17)    //Sonic icon
        {
			u64 key
			if (objA0.animation.sprite == 5 && objA0.animation.timer == 3)
			{
				key = "dataSel_slot3"
				if (Renderer.hasCustomSprite(key))
                {
                    return true
                }
			}
        }
    }
	return base.Standalone.onDrawVdpSpriteCompound(px, py, size, index, renderQueue, spriteCounter)
}